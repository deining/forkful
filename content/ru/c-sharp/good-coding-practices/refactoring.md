---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:01:30.066711-07:00
description: "\u041A\u0430\u043A: \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043E\
  \u0442\u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043C \u043F\u0440\u043E\
  \u0441\u0442\u043E\u0439 \u043C\u0435\u0442\u043E\u0434 C#, \u043A\u043E\u0442\u043E\
  \u0440\u044B\u0439 \u0432\u044B\u0447\u0438\u0441\u043B\u044F\u0435\u0442 \u0438\
  \ \u0432\u044B\u0432\u043E\u0434\u0438\u0442 \u0441\u0443\u043C\u043C\u0443 \u043C\
  \u0430\u0441\u0441\u0438\u0432\u0430 \u0447\u0438\u0441\u0435\u043B: \u0414\u043E\
  \ \u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433\u0430."
lastmod: '2024-03-13T22:44:45.072100-06:00'
model: gpt-4-0125-preview
summary: "\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043E\u0442\u0440\u0435\u0444\
  \u0430\u043A\u0442\u043E\u0440\u0438\u043C \u043F\u0440\u043E\u0441\u0442\u043E\u0439\
  \ \u043C\u0435\u0442\u043E\u0434 C#, \u043A\u043E\u0442\u043E\u0440\u044B\u0439\
  \ \u0432\u044B\u0447\u0438\u0441\u043B\u044F\u0435\u0442 \u0438 \u0432\u044B\u0432\
  \u043E\u0434\u0438\u0442 \u0441\u0443\u043C\u043C\u0443 \u043C\u0430\u0441\u0441\
  \u0438\u0432\u0430 \u0447\u0438\u0441\u0435\u043B."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как:
Давайте отрефакторим простой метод C#, который вычисляет и выводит сумму массива чисел:

До рефакторинга:
```C#
public class Calculator
{
    public void CalculateSum()
    {
        int[] numbers = { 1, 2, 3, 4, 5 };
        int sum = 0;
        for (int i = 0; i < numbers.Length; i++)
        {
            sum += numbers[i];
        }
        Console.WriteLine("Сумма равна " + sum);
    }
}
```

После рефакторинга:
```C#
public class Calculator
{
    private readonly int[] _numbers;

    public Calculator(int[] numbers)
    {
        _numbers = numbers;
    }

    public int CalculateSum()
    {
        return _numbers.Sum();
    }

    public void DisplaySum()
    {
        Console.WriteLine($"Сумма равна {CalculateSum()}");
    }
}

// Использование:
var calculator = new Calculator(new[] { 1, 2, 3, 4, 5 });
calculator.DisplaySum();
```

Благодаря рефакторингу мы разделили ответственность, сделали класс `Calculator` более гибким, позволив ему принимать любой массив чисел, и использовали LINQ для более краткого вычисления суммы.

## Подробнее
Рефакторинг берет свое начало в сообществе программирования на Smalltalk и был популяризирован в 1990-х годах благодаря книге Мартина Фаулера "Рефакторинг: улучшение дизайна существующего кода". На протяжении многих лет рефакторинг стал фундаментальной частью гибких методологий и хороших практик кодирования.

Существуют различные подходы к рефакторингу, такие как Красный-Зеленый-Рефактор в Разработке через тестирование (TDD). Это обеспечивает, что рефакторинг не вносит ошибок, начиная с проваленного теста, делая его успешным и затем очищая код.

При реализации рефакторинга крайне важно иметь всеобъемлющую набор тестов, чтобы убедиться, что ни одна функциональность не нарушена в процессе. Автоматизированные инструменты рефакторинга, такие как ReSharper для C#, также могут помочь в этом процессе, предоставляя безопасные способы изменения структур кода. Однако, инструменты должны быть дополнение к глубокому пониманию кодовой базы и принципов программирования.

## См. также
- Фундаментальная работа Мартина Фаулера о рефакторинге: [Рефакторинг: улучшение дизайна существующего кода](https://martinfowler.com/books/refactoring.html)
- Руководство Microsoft о рефакторинге в Visual Studio: [Рефакторинг (C#)](https://docs.microsoft.com/en-us/visualstudio/ide/refactoring-in-visual-studio?view=vs-2022)
- Подробный взгляд на паттерны рефакторинга с примерами: [SourceMaking Рефакторинг](https://sourcemaking.com/refactoring)
