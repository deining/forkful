---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:58.870048-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: \u041D\u0430\u0447\u043D\u0435\u043C \u0441 \u0431\u043B\u043E\u043A\
  \u0430 try-catch. \u042D\u0442\u043E \u043A\u0430\u043A \u043F\u043E\u0441\u0442\
  \u0430\u0432\u0438\u0442\u044C \u0441\u0435\u0442\u044C \u0431\u0435\u0437\u043E\
  \u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438 \u043F\u043E\u0434 \u043A\u0430\
  \u043D\u0430\u0442\u043E\u0445\u043E\u0434\u0446\u0430. \u0415\u0441\u043B\u0438\
  \ \u043E\u043D \u043F\u043E\u0441\u043A\u043E\u043B\u044C\u0437\u043D\u0435\u0442\
  \u0441\u044F, \u043E\u043D \u043D\u0435 \u0443\u043F\u0430\u0434\u0435\u0442 \u0432\
  \u043D\u0438\u0437 \u2014 \u0435\u0433\u043E \u043F\u043E\u0439\u043C\u0430\u044E\
  \u0442."
lastmod: '2024-03-13T22:44:45.070312-06:00'
model: gpt-4-0125-preview
summary: "\u041D\u0430\u0447\u043D\u0435\u043C \u0441 \u0431\u043B\u043E\u043A\u0430\
  \ try-catch."
title: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\u0431\
  \u043E\u043A"
weight: 16
---

## Как это сделать:
Начнем с блока try-catch. Это как поставить сеть безопасности под канатоходца. Если он поскользнется, он не упадет вниз — его поймают.

```C#
using System;

class ПримерОбработкиОшибок {
    static void Main() {
        try {
            int[] числа = {1, 2, 3};
            Console.WriteLine(числа[5]);  // Ой, индекс вне границ!
        } catch (IndexOutOfRangeException e) {
            Console.WriteLine("Ошибка перехвачена: " + e.Message);
        }
    }
}
```

Пример вывода при возникновении ошибок:
```
Ошибка перехвачена: Индекс находился вне границ массива.
```

Теперь добавим блок finally — это то, что происходит в любом случае, как и платежи налогов.

```C#
try {
    // Потенциально проблемный код здесь
} catch (SomeSpecificException e) {
    // Обработка этой конкретной ошибки здесь
} finally {
    // Этот код выполняется независимо от того, что произошло выше
    Console.WriteLine("Это всегда выполняется.");
}
```

## Глубокое погружение
Обработка ошибок была в C# с момента его создания. Со временем она эволюционировала. В прошлом программисты полагались на возвращаемые коды или глобальные флаги для сигнализации о проблемах — громоздко и склонно к ошибкам.

C# использует исключения, более современный подход. Исключение генерируется, когда происходит что-то неожиданное, подобно поднятию флага на игре в американский футбол. Структурированная обработка исключений с блоками try, catch и finally делает управление этими моментами более ясным и чистым, чем старые методы проверки ошибок.

Альтернативы? Конечно. Есть `UnhandledExceptionEventHandler` для исключений, которые прошли мимо. Или в асинхронном коде, обработка ошибок делается немного по-другому с объектами `Task`, которые несут собственный груз исключений.

Детали реализации — подобно мелкому шрифту — важны. Исключения могут быть дорогостоящими, тормозя производительность, если их бросать без разбора. Поэтому мы используем их для исключительных случаев, а не для управления логикой каждый день.

## См. также
- [Официальная документация по исключениям в C#](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/exception-handling)
- [Лучшие практики обработки исключений в C#](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)
