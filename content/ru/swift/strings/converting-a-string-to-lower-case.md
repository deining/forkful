---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:57:21.837101-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: Swift \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442 \u044D\u0442\
  \u0443 \u0437\u0430\u0434\u0430\u0447\u0443 \u0441 \u043F\u043E\u043C\u043E\u0449\
  \u044C\u044E \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430, \u043D\u0430\u0437\
  \u044B\u0432\u0430\u0435\u043C\u043E\u0433\u043E `lowercased`. \u0412\u043E\u0442\
  \ \u043A\u0430\u043A \u0435\u0433\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\
  \u043E\u0432\u0430\u0442\u044C."
lastmod: '2024-03-13T22:44:45.660203-06:00'
model: gpt-4-0125-preview
summary: "Swift \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442 \u044D\u0442\u0443\
  \ \u0437\u0430\u0434\u0430\u0447\u0443 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
  \u044E \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430, \u043D\u0430\u0437\u044B\
  \u0432\u0430\u0435\u043C\u043E\u0433\u043E `lowercased`."
title: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\
  \u0435 \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 \u043D\u0438\u0436\u043D\u0438\
  \u0439 \u0440\u0435\u0433\u0438\u0441\u0442\u0440"
weight: 4
---

## Как это сделать:
Swift упрощает эту задачу с помощью свойства, называемого `lowercased`. Вот как его использовать:

```Swift
let originalString = "Hello, World!"
let lowercasedString = originalString.lowercased()
print(lowercasedString) // "hello, world!"
```

Пример вывода:
```
hello, world!
```

## Подробнее:
Исторически, обеспечение единообразия регистра строк было критически важно в программировании, в основном потому, что первые компьютеры были очень чувствительны к регистру. В Swift, `lowercased()` - это метод, доступный для экземпляров типа `String`. Вызывая его, вы преобразуете все символы в строке, имеющие варианты в нижнем регистре, в их строчные формы.

Альтернативой `lowercased()` может быть ручное перебор строки и замена каждого символа его эквивалентом в нижнем регистре с использованием функции отображения. Но, честно говоря, это изобретение велосипеда.

Преобразование в нижний регистр имеет некоторые нюансы. Например, метод `lowercased()` использует текущую локаль для управления определенными правилами регистра языка, что не всегда является желаемым поведением. Если вам нужно выполнить преобразование, не зависящее от локали, вы можете использовать `lowercased(with: Locale?)` и передать `nil` как Locale:

```Swift
let turkishString = "İstanbul"
let lowercasedTurkishString = turkishString.lowercased(with: nil)
print(lowercasedTurkishString) // "i̇stanbul", корректно в Unicode, но в Турции может быть ожидаемо без точки 'I'.
```

Реализация `lowercased()` под капотом использует стандарт Unicode, который включает сложные правила отображения для символов в различных скриптах, не все из которых являются простой заменой 'a' на 'A'.

## Смотрите также:
Чтобы узнать больше о строках и преобразованиях символов в Swift, погрузитесь в следующие ресурсы:

- Документация Swift по строкам и символам: [Swift.org](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html)
- Детали отображения регистра Unicode: [Стандарт Unicode](https://www.unicode.org/reports/tr21/tr21-5.html)
- Обсуждение сравнения строк и локали: [Статья NSHipster о локали](https://nshipster.com/locale/)
