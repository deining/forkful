---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:18.048012-07:00
description: "\u041A\u0430\u043A: Haskell - \u044D\u0442\u043E \u0447\u0438\u0441\u0442\
  \u043E \u0444\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u044B\
  \u0439 \u044F\u0437\u044B\u043A, \u0433\u0434\u0435 \u0441\u0442\u0440\u043E\u043A\
  \u0438 \u043F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B\
  \ \u043A\u0430\u043A \u0441\u043F\u0438\u0441\u043A\u0438 \u0441\u0438\u043C\u0432\
  \u043E\u043B\u043E\u0432. \u0424\u0443\u043D\u043A\u0446\u0438\u044F `length`, \u0447\
  \u0430\u0441\u0442\u044C Prelude (\u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\
  \u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E\
  ,\u2026"
lastmod: '2024-04-05T21:53:45.604365-06:00'
model: gpt-4-0125-preview
summary: "Haskell - \u044D\u0442\u043E \u0447\u0438\u0441\u0442\u043E \u0444\u0443\
  \u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u044B\u0439 \u044F\u0437\
  \u044B\u043A, \u0433\u0434\u0435 \u0441\u0442\u0440\u043E\u043A\u0438 \u043F\u0440\
  \u0435\u0434\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B \u043A\u0430\u043A\
  \ \u0441\u043F\u0438\u0441\u043A\u0438 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\
  \u0432."
title: "\u041F\u043E\u0438\u0441\u043A \u0434\u043B\u0438\u043D\u044B \u0441\u0442\
  \u0440\u043E\u043A\u0438"
weight: 7
---

## Как:
```Haskell
-- Использование функции `length`
main = do
    let myString = "Привет, Haskell!"
    print $ length myString
```

Пример вывода:
```
15
```

## Подробнее
Haskell - это чисто функциональный язык, где строки представлены как списки символов. Функция `length`, часть Prelude (библиотеки по умолчанию, импортируемой в каждую программу на Haskell), работает именно с таким представлением.

Исторически, строки как списки были естественным выбором для Haskell из-за их простоты и того факта, что Lisp сделал аналогичный выбор дизайна (и повлиял на многие функциональные языки). Функция `length` просто подсчитывает элементы в этом списке.

Однако, `length` имеет сложность O(n), что означает, что функция будет работать время, пропорциональное длине строки. Это не проблема для коротких строк, но для длинных может быть неэффективно.

Альтернативы включают:
- Использование `Text` из пакета `text`, более эффективной структуры для текста в кодировке Unicode.
- Использование `ByteString` из пакета `bytestring` для двоичных данных или данных ASCII.

Оба предлагают функцию `length`, оптимизированную для своих соответствующих структур данных.

С точки зрения реализации, базовая версия функции `length` может выглядеть так:

```Haskell
myLength :: [a] -> Int
myLength [] = 0          -- Длина пустого списка равна 0
myLength (_:xs) = 1 + myLength xs  -- Рекурсивно добавляем 1 для остальной части списка
```

Для типов данных `Text` и `ByteString` у них есть свои собственные детали внутренней реализации, которые делают их более эффективными, чем простой связанный список символов.

## Смотрите также
- [Официальная документация Haskell `length`](https://hackage.haskell.org/package/base-4.16.1.0/docs/Prelude.html#v:length)
- [Пакет `text` на Hackage](https://hackage.haskell.org/package/text)
- [Пакет `bytestring` на Hackage](https://hackage.haskell.org/package/bytestring)
- [Изучаем Haskell ради большого блага! (Вводная книга)](http://learnyouahaskell.com/chapters)
