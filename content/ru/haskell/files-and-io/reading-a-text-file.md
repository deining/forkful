---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:01:19.828264-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: \u0412\u043E\u0442 \u043A\u0430\u043A \u0437\u0430\u0441\u0442\u0430\
  \u0432\u0438\u0442\u044C Haskell \u0447\u0438\u0442\u0430\u0442\u044C \u0442\u0435\
  \u043A\u0441\u0442\u043E\u0432\u044B\u0435 \u0444\u0430\u0439\u043B\u044B, \u043D\
  \u0435 \u043F\u043E\u0442\u0435\u044F. \u041E\u0442\u043A\u0440\u043E\u0439\u0442\
  \u0435 \u0432\u0430\u0448 \u043B\u044E\u0431\u0438\u043C\u044B\u0439 \u0440\u0435\
  \u0434\u0430\u043A\u0442\u043E\u0440, \u0438 \u0434\u0430\u0432\u0430\u0439\u0442\
  \u0435 \u043F\u0438\u0441\u0430\u0442\u044C \u043A\u043E\u0434."
lastmod: '2024-03-13T22:44:45.165358-06:00'
model: gpt-4-0125-preview
summary: "\u0412\u043E\u0442 \u043A\u0430\u043A \u0437\u0430\u0441\u0442\u0430\u0432\
  \u0438\u0442\u044C Haskell \u0447\u0438\u0442\u0430\u0442\u044C \u0442\u0435\u043A\
  \u0441\u0442\u043E\u0432\u044B\u0435 \u0444\u0430\u0439\u043B\u044B, \u043D\u0435\
  \ \u043F\u043E\u0442\u0435\u044F."
title: "\u0427\u0442\u0435\u043D\u0438\u0435 \u0442\u0435\u043A\u0441\u0442\u043E\u0432\
  \u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430"
weight: 22
---

## Как это сделать:
Вот как заставить Haskell читать текстовые файлы, не потея. Откройте ваш любимый редактор, и давайте писать код.

```Haskell
import System.IO

main = do
    -- Открываем файл в режиме чтения
    handle <- openFile "hello.txt" ReadMode
    -- Читаем содержимое файла
    content <- hGetContents handle
    -- Печатаем содержимое файла
    putStrLn content
    -- Не забываем закрыть дескриптор файла!
    hClose handle
```

Запустите это, и если у вас есть "hello.txt" с "Hello, World!" внутри, вы получите:

```
Hello, World!
```

Вот более короткий и изящный способ, делающий то же самое, но без лишних хлопот:

```Haskell
-- 'readFile' открывает и читает одним махом
main = do
    content <- readFile "hello.txt"
    putStrLn content
```

Выходные данные все те же,

```
Hello, World!
```

## Погружение
Давным-давно программы были асоциальными существами, в основном обрабатывающими данные, которые они сами же и генерировали. Но со временем сложность возросла, как и необходимость привлекать внешнюю информацию, так что чтение из файлов стало обыденным делом.

Haskell предлагает различные способы чтения файлов. Мы можем делать это низкоуровневым способом с помощью `openFile`, `hGetContents` и `hClose` или действовать проще с `readFile`, который аккуратно все упаковывает.

`readFile` - ленивый; он читает содержимое по мере необходимости, что эффективно по памяти для больших файлов, но может привести к сюрпризам, если файл изменяется посреди работы. Низкоуровневый подход дает больше контроля, делая его более предсказуемым, но также и более многословным. Для гигантских текстов помогают управлять памятью и обработкой более тонко такие функции Haskell, как `hGetLine`, или библиотеки вроде `conduit` и `pipes`.

Стандартные `IO` действия Haskell обращаются с файлами, используя механизмы базовой ОС. Библиотеки абстрагируют это в более удобные для пользователя операции, но в конечном счете они построены на основе `IO` монады Haskell, что обеспечивает выполнение действий в правильном порядке.

## Смотрите также
- Для официальной документации Haskell, посетите [документацию Haskell по вводу и выводу](https://www.haskell.org/tutorial/io.html).
- Если хотите узнать больше, насладитесь чашечкой знаний на [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/input-and-output).
- Углубите свое понимание управления файлами с [точки зрения IO в Real World Haskell](http://book.realworldhaskell.org/read/io.html).
- Исследуйте библиотеки потоковой передачи для больших файлов с [conduit](https://hackage.haskell.org/package/conduit) и [pipes](https://hackage.haskell.org/package/pipes).
