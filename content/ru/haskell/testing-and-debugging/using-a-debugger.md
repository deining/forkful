---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:03:40.091457-07:00
description: "\u041A\u0430\u043A: \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043F\
  \u0440\u043E\u0433\u0443\u043B\u044F\u0435\u043C\u0441\u044F \u0441 GHCi, \u0438\
  \u043D\u0442\u0435\u0440\u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0441\u0440\
  \u0435\u0434\u043E\u0439 Haskell, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u043C\
  \u043E\u0436\u0435\u0442 \u0441\u043B\u0443\u0436\u0438\u0442\u044C \u0432 \u043A\
  \u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0431\u0430\u0437\u043E\u0432\u043E\u0433\
  \u043E \u043E\u0442\u043B\u0430\u0434\u0447\u0438\u043A\u0430. \u0412\u044B \u0437\
  \u0430\u043F\u0443\u0441\u043A\u0430\u0435\u0442\u0435 \u0435\u0451 \u0441 \u0432\
  \u0430\u0448\u0438\u043C \u043A\u043E\u0434\u043E\u043C \u043D\u0430\u2026"
lastmod: '2024-03-13T22:44:45.142101-06:00'
model: gpt-4-0125-preview
summary: "\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043F\u0440\u043E\u0433\u0443\
  \u043B\u044F\u0435\u043C\u0441\u044F \u0441 GHCi, \u0438\u043D\u0442\u0435\u0440\
  \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0441\u0440\u0435\u0434\u043E\u0439\
  \ Haskell, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u043C\u043E\u0436\u0435\u0442\
  \ \u0441\u043B\u0443\u0436\u0438\u0442\u044C \u0432 \u043A\u0430\u0447\u0435\u0441\
  \u0442\u0432\u0435 \u0431\u0430\u0437\u043E\u0432\u043E\u0433\u043E \u043E\u0442\
  \u043B\u0430\u0434\u0447\u0438\u043A\u0430."
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u043E\u0442\u043B\u0430\u0434\u0447\u0438\u043A\u0430"
weight: 35
---

## Как:
Давайте прогуляемся с GHCi, интерактивной средой Haskell, которая может служить в качестве базового отладчика. Вы запускаете её с вашим кодом на Haskell и начинаете разбираться. Вот пример:

```Haskell
main :: IO ()
main = do
    putStrLn "Привет, как тебя зовут?"
    name <- getLine
    putStrLn $ "Привет, " ++ name ++ "! Давай отлаживать."
    let result = buggyFunction 5
    print result

buggyFunction :: Int -> Int
buggyFunction n = n * 2 -- Представим, что здесь ошибка
```

Чтобы начать отладку с GHCi:

```bash
$ ghci YourHaskellFile.hs
```

Установите точку останова на `buggyFunction`:

```Haskell
Prelude> :break buggyFunction
```

Запустите вашу программу:

```Haskell
Prelude> :main
Привет, как тебя зовут?
```

Ваша программа останавливается на `buggyFunction`. Теперь вы можете инспектировать переменные, проходить через код пошагово и оценивать выражения.

## Глубокое погружение:
Исторически репутация Haskell за счет чистых функций и сильной типизации привела к мнению, что инструменты отладки менее критичны. На деле это отличается — сложные программы всегда выигрывают от хороших инструментов отладки. GHCi предоставляет базовые команды отладки. Однако для более наглядного опыта или приложений большего масштаба вы можете исследовать ИДЕ с интегрированными отладчиками, такие как Visual Studio Code с расширениями для Haskell или плагин IntelliJ для Haskell.

К альтернативам отладчика относятся использование операторов печати, известных как "Отладка printf", или использование сильной системы типов Haskell, чтобы сделать некорректные состояния непредставимыми. Тем не менее, иногда ничто не заменит пошаговое прохождение через код.

Что касается деталей реализации, отладчик Haskell работает с системой выполнения. Он может обрабатывать точки останова, пошаговое выполнение и позволять инспектировать переменные. Однако, поскольку Haskell имеет ленивую оценку, вещи могут получиться немного неинтуитивными. Отладка программы на Haskell часто означает внимание к тому, когда и как оцениваются выражения.

## Смотри также:
- [Руководство пользователя GHC - Отладчик](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html)
- [Плагин IntelliJ для Haskell](https://plugins.jetbrains.com/plugin/8258-intellij-haskell)
