---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:55:58.881059-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: Clojure \u0434\u0435\u043B\u0430\u0435\u0442 \u043A\u043E\u043D\u043A\
  \u0430\u0442\u0435\u043D\u0430\u0446\u0438\u044E \u0441\u0442\u0440\u043E\u043A\
  \ \u043F\u0440\u043E\u0441\u0442\u043E\u0439 \u0441 \u043F\u043E\u043C\u043E\u0449\
  \u044C\u044E \u0444\u0443\u043D\u043A\u0446\u0438\u0438 `str`. \u0414\u0430\u0432\
  \u0430\u0439\u0442\u0435 \u043F\u043E\u0433\u0440\u0443\u0437\u0438\u043C\u0441\u044F\
  \ \u043F\u0440\u044F\u043C\u043E \u0432 \u044D\u0442\u043E."
lastmod: '2024-03-13T22:44:44.334948-06:00'
model: gpt-4-0125-preview
summary: "Clojure \u0434\u0435\u043B\u0430\u0435\u0442 \u043A\u043E\u043D\u043A\u0430\
  \u0442\u0435\u043D\u0430\u0446\u0438\u044E \u0441\u0442\u0440\u043E\u043A \u043F\
  \u0440\u043E\u0441\u0442\u043E\u0439 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
  \u044E \u0444\u0443\u043D\u043A\u0446\u0438\u0438 `str`."
title: "\u0421\u043A\u043B\u0435\u0438\u0432\u0430\u043D\u0438\u0435 \u0441\u0442\u0440\
  \u043E\u043A"
weight: 3
---

## Как это сделать:
Clojure делает конкатенацию строк простой с помощью функции `str`. Давайте погрузимся прямо в это:

```clojure
;; Простая конкатенация с функцией str
(str "Hello, " "world!")
;; => "Hello, world!"

;; Конкатенация нескольких строк
(str "Clojure" " это" " прекрасно!")
;; => "Clojure это прекрасно!"

;; Сочетание строк и других значений
(str "Ответ " 42)
;; => "Ответ 42"

;; Использование apply для конкатенации последовательности строк
(apply str ["Соедините" " " "эти" " " "строки!"])
;; => "Соедините эти строки!"
```

Отлично, теперь вы видели это на практике. Просто помните, что `str` работает с любым значением, вызывая на нем `toString`. Если это nil, вы получите строку "nil".

## Погружение в Детали
Исторически, конкатенация строк существует с тех пор, как нам потребовалась обработка текста программным способом, и каждый язык предлагает свои методы. В Clojure, `str` является частью основной библиотеки, введенной для простоты и унификации.

Альтернативы `str`? Да! `StringBuilder` может быть более эффективен для большого количества конкатенаций, особенно в циклах. Clojure может вызывать Java методы, так что вы также можете использовать `StringBuilder`:

```clojure
;; Использование StringBuilder для повышения эффективности
(let [builder (StringBuilder.)]
  (.append builder "Это")
  (.append builder " более")
  (.append builder " эффективный способ!")
  (.toString builder))
;; => "Это более эффективный способ!"
```

Почему тогда не использовать всегда `StringBuilder`? Для большинства повседневных задач `str` проще и достаточно быстр. `StringBuilder` выделяется в сценариях высокой производительности с множеством конкатенаций.

С точки зрения реализации, поскольку Clojure работает на JVM, он получает выгоду из возможностей обработки строк Java. Однако, как и в случае со строками `String` в Java, каждый вызов `str` создает новую `String`, что может быть важным с точки зрения использования памяти.

## Смотрите также:
- Документация функции `str` в Clojure: [Clojure Strings](https://clojuredocs.org/clojure.core/str)
- `StringBuilder` в Java: [Документация StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html)
- Практическое руководство по `str` и не только: [Clojure для Смелых и Правдивых](https://www.braveclojure.com/clojure-for-the-brave-and-true/)
