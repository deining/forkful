---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:00:56.284616-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0434\u0435\u043B\u0430\u0442\
  \u044C: \u041F\u0440\u043E\u0441\u0442\u043E \u0438 \u043D\u0435\u043F\u0440\u0438\
  \u043D\u0443\u0436\u0434\u0435\u043D\u043D\u043E, \u0432\u044B \u0432\u044B\u0432\
  \u043E\u0434\u0438\u0442\u0435 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\
  \u044E, \u0447\u0442\u043E\u0431\u044B \u0443\u0432\u0438\u0434\u0435\u0442\u044C\
  , \u0447\u0442\u043E \u043F\u0440\u043E\u0438\u0441\u0445\u043E\u0434\u0438\u0442\
  . \u0412\u043E\u0442 \u043A\u043B\u0430\u0441\u0441\u0438\u043A\u0430."
lastmod: '2024-03-13T22:44:44.275186-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u0440\u043E\u0441\u0442\u043E \u0438 \u043D\u0435\u043F\u0440\u0438\
  \u043D\u0443\u0436\u0434\u0435\u043D\u043D\u043E, \u0432\u044B \u0432\u044B\u0432\
  \u043E\u0434\u0438\u0442\u0435 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\
  \u044E, \u0447\u0442\u043E\u0431\u044B \u0443\u0432\u0438\u0434\u0435\u0442\u044C\
  , \u0447\u0442\u043E \u043F\u0440\u043E\u0438\u0441\u0445\u043E\u0434\u0438\u0442\
  ."
title: "\u0412\u044B\u0432\u043E\u0434 \u043E\u0442\u043B\u0430\u0434\u043E\u0447\u043D\
  \u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438"
weight: 33
---

## Как это делать:
Просто и непринужденно, вы выводите информацию, чтобы увидеть, что происходит. Вот классика:

```Python
print("Привет, охотники за багами!")
```

Почувствовали себя детективом? Теперь давайте посмотрим, как ведут себя ваши переменные:

```Python
buggy_number = 42
print(f"Отладка: Число равно {buggy_number}")
```

Когда дела обстоят сложнее, можно заглянуть в список:

```Python
buggy_list = [1, 2, 3]
print(f"Отладка: Список содержит {buggy_list}")
```

Запустите эти фрагменты, и ваш вывод будет следующим:

```
Привет, охотники за багами!
Отладка: Число равно 42
Отладка: Список содержит [1, 2, 3]
```

## Подробнее
Отладка путем вывода имеет долгую историю, уходящую корнями к тем временам, когда по земле ходили динозавры (также известные как ранние дни вычислительной техники). Это просто и универсально применимо, потому что позволяет выводить любую информацию, которую вы хотите проверить.

Хотя `print()` является быстрым и грубым инструментом в Python, существуют альтернативы. Для настоящего расследования вы можете использовать ведение журнала с различными уровнями, такими как DEBUG, INFO, WARNING и т.д. Таким образом, вы можете контролировать, что печатается, а что подавляется.

Иногда вы можете слышать о сложных отладчиках, которые позволяют останавливать время (некоторым образом) и высматривать ваш код во время его выполнения. Они очень мощные и стоит их изучить, но не позволяйте им заставить вас чувствовать себя плохо за использование быстрого `print()` время от времени.

Что касается реализации, то красота `print()` в его простоте. Просто помните, что постоянный вывод на консоль может замедлить вас, если вы делаете это миллион раз в цикле. И это может стать очень запутанным очень быстро. Убирайте или комментируйте эти строки, как только вы нашли и устранили ошибки.

## Смотрите также
Для получения дополнительной информации о выводе и отладке в Python:
- Встроенная функция `print()` в Python: [Документация Python о print](https://docs.python.org/3/library/functions.html#print)
- Ведение журнала в Python: [Как пользоваться журналом](https://docs.python.org/3/howto/logging.html)
- Для любителей отладчиков: [Документация Python о pdb](https://docs.python.org/3/library/pdb.html)
