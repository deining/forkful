---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:51.047975-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: \u041F\u0440\u0438\u043C\u0435\u0440 \u0432\u044B\u0432\u043E\u0434\
  \u0430 \u043F\u0440\u0438 \u0432\u0432\u043E\u0434\u0435 \u043D\u0435\u0434\u043E\
  \u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0433\u043E \u0447\u0438\u0441\u043B\u0430\
  \ \u0434\u043B\u044F \u043F\u0435\u0440\u0432\u043E\u0433\u043E \u0431\u043B\u043E\
  \u043A\u0430."
lastmod: '2024-04-05T21:53:44.916707-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0432\u044B\u0432\u043E\u0434\u0430\
  \ \u043F\u0440\u0438 \u0432\u0432\u043E\u0434\u0435 \u043D\u0435\u0434\u043E\u043F\
  \u0443\u0441\u0442\u0438\u043C\u043E\u0433\u043E \u0447\u0438\u0441\u043B\u0430\
  \ \u0434\u043B\u044F \u043F\u0435\u0440\u0432\u043E\u0433\u043E \u0431\u043B\u043E\
  \u043A\u0430."
title: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\u0431\
  \u043E\u043A"
weight: 16
---

## Как это сделать:
```python
# Базовый блок try-except
try:
    # рискованный код
    number = int(input("Введите число: "))
except ValueError:
    # обработка ошибки
    print("Это не число!")

# Указание нескольких исключений
try:
    # код, который может вызвать разные исключения
    result = 10 / int(input("Введите делитель: "))
except ZeroDivisionError:
    print("Ой! Нельзя делить на ноль.")
except ValueError:
    print("Мне нужно число, дружище.")

# Использование else и finally
try:
    number = int(input("Введите число для возведения в квадрат: "))
except ValueError:
    print("Я сказал число!")
else:
    # ошибок не произошло
    print("Ваше число в квадрате:", number**2)
finally:
    # выполняется всегда
    print("Спасибо, что попробовали это!")
```

Пример вывода при вводе недопустимого числа для первого блока:
```
Введите число: привет
Это не число!
```

## Подробнее
С самого начала программирования, обработка ошибок была критически важна. Ранние подходы были элементарными, например, проверка условий перед каждой рискованной операцией. Синтаксис `try-except` Python произошел от наследия обработки исключений в более старых языках, таких как C++ и Java, упрощая процесс.

Когда вы используете `try` с блоком кода, Python следит за любыми исключениями. Если появляется ошибка, блок `except` ловит ее. Вы можете быть конкретными по поводу ловли исключений или поймать их всех с помощью пустого `except`. Однако, лучше сначала указывать конкретику – это точно, а не сеть, ловящая всё подряд.

`else` и `finally` – дополнения к этой концепции. Блок `else` выполняется, если в блоке try не возникло ошибок. `finally` – это надежный друг, который выполняется в любом случае – подумайте о операциях по очистке.

Альтернативы? Конечно, они есть. Некоторые языки используют коды возврата вместо исключений. Вы также можете столкнуться с операторами `with` для обработки ресурсов или `assertions`, которые проверяют условия во время разработки. Но когда мы говорим об надежных стратегиях обработки ошибок, модель try-catch выделяется своей читаемостью и структурой.

## Смотрите также
Вот некоторые хорошие дополнительные ресурсы для глубокого погружения:

- Официальная документация Python об ошибках и исключениях: [Python Docs – Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)
- Руководство от Real Python по данной теме: [Real Python - Блок try/except/else/finally](https://realpython.com/python-exceptions/)
- Продуманное обсуждение лучших практик обработки ошибок: [Stack Overflow – Как мне правильно игнорировать исключения?](https://stackoverflow.com/questions/4990718/about-catching-any-exception)
