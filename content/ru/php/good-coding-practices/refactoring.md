---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:01:24.486279-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0434\u0435\u043B\u0430\u0435\
  \u0442\u0441\u044F: \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0432\u043E\u0437\
  \u044C\u043C\u0435\u043C \u043A\u043B\u0430\u0441\u0441\u0438\u0447\u0435\u0441\u043A\
  \u0438\u0439 \u0444\u0440\u0430\u0433\u043C\u0435\u043D\u0442 PHP-\u043A\u043E\u0434\
  \u0430 \u0438 \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u043C \u043A \u043D\u0435\
  \u043C\u0443 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u043C\u0430\u0433\u0438\
  \u0438 \u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433\u0430\
  . \u0414\u043E \u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433\
  \u0430 \u043D\u0430\u0448 \u043A\u043E\u0434 \u043C\u043E\u0436\u0435\u0442 \u0432\
  \u044B\u0433\u043B\u044F\u0434\u0435\u0442\u044C \u0442\u0430\u043A."
lastmod: '2024-03-13T22:44:45.226245-06:00'
model: gpt-4-0125-preview
summary: "\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0432\u043E\u0437\u044C\u043C\
  \u0435\u043C \u043A\u043B\u0430\u0441\u0441\u0438\u0447\u0435\u0441\u043A\u0438\u0439\
  \ \u0444\u0440\u0430\u0433\u043C\u0435\u043D\u0442 PHP-\u043A\u043E\u0434\u0430\
  \ \u0438 \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u043C \u043A \u043D\u0435\u043C\
  \u0443 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u043C\u0430\u0433\u0438\u0438\
  \ \u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433\u0430."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как это делается:
Давайте возьмем классический фрагмент PHP-кода и применим к нему немного магии рефакторинга.

До рефакторинга наш код может выглядеть так:

```php
function printOrderDetails($order) {
    foreach ($order as $item) {
        echo "Item: " . $item['name'];
        echo " - Price: " . $item['price'];
        echo "<br>";
    }
    
    if (!empty($order)) {
        echo "Total: " . array_sum(array_column($order, 'price'));
    }
}
```

Но мы можем рефакторить этот код, чтобы улучшить его ясность и модульность:

```php
function printItem($item) {
    echo "Item: {$item['name']} - Price: {$item['price']}<br>";
}

function calculateTotal($order) {
    return array_sum(array_column($order, 'price'));
}

function printOrderDetails(array $order) {
    array_walk($order, 'printItem');

    if (!empty($order)) {
        echo "Total: " . calculateTotal($order);
    }
}
```
Разбивая функцию `printOrderDetails` на меньшие функции, наш код становится более читаемым и проще для отладки.

## Глубокое погружение
Рефакторинг берет свои корни из сообщества программистов на Smalltalk в начале 1990-х годов и был дополнительно популяризирован семинарной книгой Мартина Фаулера "Рефакторинг: Улучшение дизайна существующего кода" (1999). Хотя рефакторинг может быть применен к любому языку программирования, динамичная природа PHP предоставляет некоторые уникальные вызовы и возможности.

Альтернативами рефакторингу могут быть полная перезапись кода с нуля, что зачастую более рискованно и занимает больше времени. В экосистеме PHP инструменты, такие как PHPStan и Rector, могут автоматически выявлять и выполнять некоторые операции рефакторинга соответственно. С точки зрения реализации, ключевыми практиками для обеспечения успешного рефакторинга без внесения ошибок являются проведение небольших рефакторингов и тщательное тестирование с помощью модульных тестов.

## См. также
- Книга Мартина Фаулера по рефакторингу: https://martinfowler.com/books/refactoring.html
- PHPStan, инструмент статического анализа PHP: https://phpstan.org/
- Rector, инструмент для автоматического рефакторинга кода PHP: https://getrector.org/
- Модульное тестирование в PHP с PHPUnit: https://phpunit.de/
