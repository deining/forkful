---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:54:02.501668-07:00
description: "\u041A\u0430\u043A \u044D\u0442\u043E \u0441\u0434\u0435\u043B\u0430\
  \u0442\u044C: \u0412 C \u0441\u0442\u0440\u043E\u043A\u0438 \u2013 \u044D\u0442\u043E\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u044B \u0441\u0438\u043C\u0432\u043E\u043B\
  \u043E\u0432, \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u044E\u0449\
  \u0438\u0435\u0441\u044F \u043D\u0443\u043B\u0435\u0432\u044B\u043C \u0441\u0438\
  \u043C\u0432\u043E\u043B\u043E\u043C (`\\0`). \u0412 \u043E\u0442\u043B\u0438\u0447\
  \u0438\u0435 \u043E\u0442 \u0432\u044B\u0441\u043E\u043A\u043E\u0443\u0440\u043E\
  \u0432\u043D\u0435\u0432\u044B\u0445 \u044F\u0437\u044B\u043A\u043E\u0432, C \u043D\
  \u0435 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u043B\u044F\u0435\u0442\
  \u2026"
lastmod: '2024-03-13T22:44:45.901772-06:00'
model: gpt-4-0125-preview
summary: "\u0412 C \u0441\u0442\u0440\u043E\u043A\u0438 \u2013 \u044D\u0442\u043E\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u044B \u0441\u0438\u043C\u0432\u043E\u043B\
  \u043E\u0432, \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u044E\u0449\
  \u0438\u0435\u0441\u044F \u043D\u0443\u043B\u0435\u0432\u044B\u043C \u0441\u0438\
  \u043C\u0432\u043E\u043B\u043E\u043C (`\\0`)."
title: "\u0421\u0446\u0435\u043F\u043B\u0435\u043D\u0438\u0435 \u0441\u0442\u0440\u043E\
  \u043A"
weight: 3
---

## Как это сделать:
В C строки – это массивы символов, заканчивающиеся нулевым символом (`\0`). В отличие от высокоуровневых языков, C не предоставляет встроенной функции конкатенации строк. Вместо этого вы используете функции `strcat()` или `strncat()` из библиотеки `<string.h>`.

Вот простой пример с использованием `strcat()`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char destination[50] = "Hello, ";
    char source[] = "World!";

    strcat(destination, source);

    printf("%s\n", destination);  // Вывод: Hello, World!
    return 0;
}
```

Функция `strcat()` принимает два аргумента: строку назначения (которая должна иметь достаточно места для хранения результата конкатенации) и исходную строку. Она добавляет исходную строку к строке назначения.

Для более точного контроля над количеством конкатенируемых символов безопаснее использовать `strncat()`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char destination[50] = "Hello, ";
    char source[] = "World!";
    int num = 3; // Количество добавляемых символов

    strncat(destination, source, num);

    printf("%s\n", destination);  // Вывод: Hello, Wor
    return 0;
}
```

Это ограничивает конкатенацию первыми `num` символами исходной строки, помогая предотвратить переполнение буфера.

## Более глубокое погружение
Функции `strcat()` и `strncat()` были частью стандартной библиотеки C с момента её создания, отражая низкоуровневый характер языка, который требует ручного управления строками и памятью. В отличие от многих современных языков программирования, которые рассматривают строки как объекты первого класса с встроенными операторами конкатенации (такими как `+` или `.concat()`), подход C требует более глубокого понимания указателей, выделения памяти и потенциальных подводных камней, таких как переполнение буфера.

Несмотря на то что `strcat()` и `strncat()` широко используются, их часто критикуют за потенциальную возможность создания уязвимостей безопасности, если их использовать неосторожно. Переполнения буфера, при которых данные превышают выделенную память, могут привести к сбоям или быть использованы для выполнения произвольного кода. В результате программисты всё чаще обращаются к более безопасным альтернативам, таким как `snprintf()`, которая обеспечивает более предсказуемое поведение, ограничивая количество символов, записываемых в строку назначения, на основе её размера:

```c
char destination[50] = "Hello, ";
char source[] = "World!";
snprintf(destination + strlen(destination), sizeof(destination) - strlen(destination), "%s", source);
```

Этот метод более громоздкий, но значительно безопаснее, подчеркивая сдвиг в практиках программирования на C в сторону приоритета безопасности и надежности перед краткостью.

Несмотря на эти вызовы, конкатенация строк в C является основным навыком, критически важным для эффективного программирования на языке. Понимание её нюансов и связанных с ней рисков ключевое для овладения программированием на C.
