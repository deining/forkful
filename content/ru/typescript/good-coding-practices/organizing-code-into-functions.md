---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:00:01.801717-07:00
description: "\u041A\u0430\u043A: \u041F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\
  \u044C\u0442\u0435, \u0447\u0442\u043E \u0432\u044B \u0441\u043E\u0437\u0434\u0430\
  \u0435\u0442\u0435 \u0431\u0430\u0437\u043E\u0432\u044B\u0439 \u043A\u0430\u043B\
  \u044C\u043A\u0443\u043B\u044F\u0442\u043E\u0440. \u0412\u043C\u0435\u0441\u0442\
  \u043E \u0442\u043E\u0433\u043E, \u0447\u0442\u043E\u0431\u044B \u043F\u0438\u0441\
  \u0430\u0442\u044C \u043B\u043E\u0433\u0438\u043A\u0443 \u0441\u043B\u043E\u0436\
  \u0435\u043D\u0438\u044F \u0432\u0435\u0437\u0434\u0435, \u0433\u0434\u0435 \u043E\
  \u043D\u0430 \u0432\u0430\u043C \u043D\u0443\u0436\u043D\u0430, \u0441\u043E\u0437\
  \u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u044E `add`."
lastmod: '2024-03-13T22:44:44.599242-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u044C\u0442\u0435, \u0447\
  \u0442\u043E \u0432\u044B \u0441\u043E\u0437\u0434\u0430\u0435\u0442\u0435 \u0431\
  \u0430\u0437\u043E\u0432\u044B\u0439 \u043A\u0430\u043B\u044C\u043A\u0443\u043B\u044F\
  \u0442\u043E\u0440."
title: "\u041E\u0440\u0433\u0430\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043A\u043E\
  \u0434\u0430 \u0432 \u0444\u0443\u043D\u043A\u0446\u0438\u0438"
weight: 18
---

## Как:
Представьте, что вы создаете базовый калькулятор. Вместо того, чтобы писать логику сложения везде, где она вам нужна, создайте функцию `add`:

```TypeScript
function add(x: number, y: number): number {
  return x + y;
}

console.log(add(5, 7)); // Пример вывода: 12
```

Теперь допустим, нам нужна функция для умножения:

```TypeScript
function multiply(x: number, y: number): number {
  return x * y;
}

console.log(multiply(3, 4)); // Пример вывода: 12
```
Заметили, как мы сосредотачиваемся на одной задаче на функцию? В этом и заключается суть организации кода.

## Подробнее
Исторически, по мере развития языков программирования, функции стали жизненно необходимыми в структурировании кода, черпая идеи из математических функций. Они являются столпом процедурного программирования и продолжают жить в парадигмах объектно-ориентированного и функционального программирования.

Альтернативы? Можно, конечно, не использовать функции, но это прямой билет в Город Спагетти. Или вы можете перейти к ООП (Объектно-Ориентированное Программирование) и упаковать функционал в методы — которые по сути являются функциями, принадлежащими объектам.

С точки зрения реализации, TypeScript настаивает на типах. Определение входных и выходных типов для функций не просто хороший тон; это необходимость для чистого кода на TypeScript. К тому же, с TypeScript вы получаете такие замечательные функции, как перегрузки, обобщения и необязательные параметры, чтобы насытить ваши функции дополнительной мощью.

## Смотрите также
Изучите эти ресурсы, чтобы повысить уровень ваших навыков работы с функциями:

- [Руководство по TypeScript – Функции](https://www.typescriptlang.org/docs/handbook/2/functions.html): Ваша Библия по функциям TypeScript.
- [Чистый Код JavaScript](https://github.com/ryanmcdermott/clean-code-javascript#functions): Примените принципы Чистого Кода к вашим функциям JavaScript.
- [Вы Не Знаете JS – Область видимости и Замыкания](https://github.com/getify/You-Dont-Know-JS): Поймите, как функции работают с областями видимости и замыканиями в JavaScript.
