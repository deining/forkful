---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:56:40.913131-07:00
description: "\u041A\u0430\u043A: Rust \u043F\u0440\u0435\u0434\u043B\u0430\u0433\u0430\
  \u0435\u0442 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0441\u043F\
  \u043E\u0441\u043E\u0431\u043E\u0432 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\
  \u0438\u044F \u0442\u0435\u043A\u0441\u0442\u043E\u0432. \u0414\u0430\u0432\u0430\
  \u0439\u0442\u0435 \u0440\u0430\u0437\u0431\u0438\u0440\u0430\u0442\u044C\u0441\u044F\
  . #."
lastmod: '2024-03-13T22:44:44.651065-06:00'
model: gpt-4-0125-preview
summary: "Rust \u043F\u0440\u0435\u0434\u043B\u0430\u0433\u0430\u0435\u0442 \u043D\
  \u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0441\u043F\u043E\u0441\u043E\u0431\
  \u043E\u0432 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F \u0442\
  \u0435\u043A\u0441\u0442\u043E\u0432."
title: "\u0421\u043A\u043B\u0435\u0438\u0432\u0430\u043D\u0438\u0435 \u0441\u0442\u0440\
  \u043E\u043A"
weight: 3
---

## Как:
Rust предлагает несколько способов соединения текстов. Давайте разбираться.

### Использование оператора `+`
```Rust
let hello = "Hello".to_string();
let world = " world!";
let result = hello + world;
println!("{}", result); // Вывод: Hello world!
```
Оператор `+` приклеивает `" world!"` к `"Hello"`, но будьте внимательны, `hello` должен быть `String`, а не срезом.

### Макрос `format!`
```Rust
let mood = "happy";
let message = format!("Желаем вам {} дня!", mood);
println!("{}", message); // Вывод: Желаем вам счастливого дня!
```
`format!` работает как `println!`, сочетая переменные с текстом. Очень удобен для шаблонов.

### Добавление к строке
```Rust
let mut tip = "Remember to".to_string();
tip.push_str(" breathe.");
println!("{}", tip); // Вывод: Remember to breathe.
```
`push_str` добавляет срез к `String`. Хорошо подходит для последовательного добавления частей.

## Глубокое погружение
Конкатенация строк не новый концепт. Она существует с зари программирования; в конце концов, нам всегда нужно было соединять слова вместе.

В Rust, `String` – это растущая, изменяемая, собственная строка в кодировке UTF-8. Есть альтернативы, например, `&str`, срез строки, который представляет собой вид на `String`.

У каждого метода есть свои компромиссы:

- Оператор `+` быстр для одного или двух соединений, но "поглощает" левый операнд (берет владение). Каждый `+` также выделяет память, что может накапливаться.
  
- `format!` не забирает собственные значения, что вежливо, но может быть медленнее из-за своей гибкости и выделения памяти для каждого вызова. Это ваш швейцарский нож для сборки строк.

- `push_str` эффективен для повторяющегося добавления. Он не выделяет память, пока `String` не потребует больше места.

Фокус Rust на владении и заимствовании означает, что он обращается со строками немного иначе, чем языки вроде Python или JavaScript. Это различие обеспечивает безопасность памяти, но также может сопровождаться кривой обучения.

## Смотрите также
Для более глубокого изучения:
- Книга по Rust о строках: https://doc.rust-lang.org/book/ch08-02-strings.html
- Rust на примерах о строках: https://doc.rust-lang.org/rust-by-example/std/str.html
- Документация по API std::string::String в Rust: https://doc.rust-lang.org/std/string/struct.String.html
