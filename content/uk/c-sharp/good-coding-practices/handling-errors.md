---
date: 2024-01-26 00:51:29.384231-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u041F\u043E\u0447\u043D\u0435\u043C\u043E \u0437 \u0431\u043B\u043E\u043A\u0443\
  \ try-catch. \u0426\u0435 \u043D\u0456\u0431\u0438 \u0441\u0442\u0430\u0432\u043B\
  \u0435\u043D\u043D\u044F \u0437\u0430\u0445\u0438\u0441\u043D\u043E\u0457 \u0441\
  \u0456\u0442\u043A\u0438 \u043F\u0456\u0434 \u0441\u0442\u0440\u043E\u043F\u0438\
  \u043B\u0430. \u042F\u043A\u0449\u043E \u0432\u043E\u043D\u0438 \u043F\u043E\u0441\
  \u043B\u0438\u0437\u043D\u0443\u0442\u044C\u0441\u044F, \u0432\u043E\u043D\u0438\
  \ \u043D\u0435 \u043F\u0430\u0434\u0430\u044E\u0442\u044C \u0432\u043D\u0438\u0437\
  \ \u2013 \u0457\u0445 \u043B\u043E\u0432\u043B\u044F\u0442\u044C."
lastmod: '2024-03-13T22:44:49.301776-06:00'
model: gpt-4-1106-preview
summary: "\u041F\u043E\u0447\u043D\u0435\u043C\u043E \u0437 \u0431\u043B\u043E\u043A\
  \u0443 try-catch."
title: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\u043E\
  \u043A"
weight: 16
---

## Як це зробити:
Почнемо з блоку try-catch. Це ніби ставлення захисної сітки під стропила. Якщо вони послизнуться, вони не падають вниз – їх ловлять.

```C#
using System;

class ErrorHandlingExample {
    static void Main() {
        try {
            int[] numbers = {1, 2, 3};
            Console.WriteLine(numbers[5]);  // Ой Лишенько, індекс за межами!
        } catch (IndexOutOfRangeException e) {
            Console.WriteLine("Помилка вловлена: " + e.Message);
        }
    }
}
```

Приклад виводу, коли щось пішло не так:
```
Помилка вловлена: Індекс знаходився за межами масиву.
```

Тепер ми додаємо блок finally – це те, що відбувається в будь-якому випадку, як сплата податків.

```C#
try {
    // Потенційно проблемний код тут
} catch (SomeSpecificException e) {
    // Обробка цієї конкретної помилки тут
} finally {
    // Цей код виконується незалежно від того, що відбувається вище
    Console.WriteLine("Це завжди виконується.");
}
```

## Глибоке занурення
Обробка помилок була у C# з самого його створення. З часом вона еволюціонувала. Колись програмісти покладалися на коди повернення або глобальні прапорці для сигналізації про проблеми – це було громіздко і схильно до помилок.

C# використовує виключення (exceptions), більш сучасний підхід. Виключення генерується, коли стається щось несподіване, точно так само, як кидають прапорець на поле під час футбольного матчу. Структуроване управління виключеннями із блоками try, catch і finally робить процес управління цими моментами яснішим та чистішим, ніж методи перевірки помилок старої школи.

Є альтернативи? Звісно. Є `UnhandledExceptionEventHandler` для виключень, що прослизнули повз. Або у асинхронному коді, обробка помилок стає дещо іншою за допомогою об'єктів `Task`, які несуть у собі власне вантаж виключень.

Деталі реалізації – подібні до дрібного шрифту – мають значення. Виключення можуть бути дороговартісними, знижуючи продуктивність, якщо генеруватись без розбору. Тому ми використовуємо їх для виняткових випадків, а не для щоденного контролю логіки.

## Дивіться також
- [Офіційна документація з виключень у C#](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/exception-handling)
- [Кращі практики обробки виключень в C#](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)
