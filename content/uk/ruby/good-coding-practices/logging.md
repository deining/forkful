---
date: 2024-01-26 01:09:19.909409-07:00
description: "\u042F\u043A \u0440\u043E\u0431\u0438\u0442\u0438: Ruby \u043C\u0430\
  \u0454 \u0432\u0431\u0443\u0434\u043E\u0432\u0430\u043D\u0438\u0439 \u043C\u043E\
  \u0434\u0443\u043B\u044C \u0434\u043B\u044F \u043B\u043E\u0433\u0443\u0432\u0430\
  \u043D\u043D\u044F, `Logger`, \u044F\u043A\u0438\u043C \u043D\u0430\u0434\u0437\u0432\
  \u0438\u0447\u0430\u0439\u043D\u043E \u043B\u0435\u0433\u043A\u043E \u043A\u043E\
  \u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0442\u0438\u0441\u044F. \u041E\u0441\
  \u044C \u0448\u0432\u0438\u0434\u043A\u0438\u0439 \u043F\u0440\u0438\u043A\u043B\
  \u0430\u0434, \u0449\u043E\u0431 \u0432\u0438 \u043C\u043E\u0433\u043B\u0438 \u0440\
  \u043E\u0437\u043F\u043E\u0447\u0430\u0442\u0438."
lastmod: '2024-03-13T22:44:50.238725-06:00'
model: gpt-4-1106-preview
summary: "Ruby \u043C\u0430\u0454 \u0432\u0431\u0443\u0434\u043E\u0432\u0430\u043D\
  \u0438\u0439 \u043C\u043E\u0434\u0443\u043B\u044C \u0434\u043B\u044F \u043B\u043E\
  \u0433\u0443\u0432\u0430\u043D\u043D\u044F, `Logger`, \u044F\u043A\u0438\u043C \u043D\
  \u0430\u0434\u0437\u0432\u0438\u0447\u0430\u0439\u043D\u043E \u043B\u0435\u0433\u043A\
  \u043E \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0442\u0438\u0441\u044F\
  ."
title: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F"
weight: 17
---

## Як робити:
Ruby має вбудований модуль для логування, `Logger`, яким надзвичайно легко користуватися. Ось швидкий приклад, щоб ви могли розпочати:

```ruby
require 'logger'

# Створіть Logger, що виводить до STDOUT
logger = Logger.new(STDOUT)
logger.level = Logger::INFO

# Приклад повідомлень до логу
logger.info("Це інформаційне повідомлення")
logger.warn("Це попередження")
logger.error("Це повідомлення про помилку")
```

Запуск вищенаведеного скрипта дасть приблизно такий результат:

```
I, [2023-03-15T10:00:00.123456 #1234]  INFO -- : Це інформаційне повідомлення
W, [2023-03-15T10:00:01.234567 #1234]  WARN -- : Це попередження
E, [2023-03-15T10:00:02.345678 #1234] ERROR -- : Це повідомлення про помилку
```

Ви можете налаштувати формат логу та рівень, щоб відфільтрувати непотрібний шум, а також направити логи до різних виходів, як-от файл чи навіть зовнішній сервіс логування.

## Поглиблено
Логування - це мов би старовинна традиція в програмуванні. Історично логи були простими текстовими файлами, які вручну оброблялися за допомогою інструментів на кшталт `grep`. Але концепція переросла в цілу екосистему потужних фреймворків та сервісів логування, як-от Log4j, Syslog в Linux або Sematext і Loggly в епоху хмарних технологій.

`Logger` в Ruby - це простий спосіб розпочати, але якщо вам потрібно більше потужності та гнучкості, ви могли б ознайомитися з альтернативами, такими як Lograge чи Semantic Logger. Ці бібліотеки добре працюють з Ruby програмами, пропонуючи більш точний контроль за форматуванням логів, включно зі структурованими логами (формат JSON), кращу продуктивність та безшовну інтеграцію з іншими сервісами.

Кожна бібліотека логування Ruby має свій власний спосіб роботи, але всі вони, в основному, обертаються навколо ідеї інстанса логера, до якого ви надсилаєте повідомлення. Логер обробляє ці повідомлення залежно від встановлених рівнів - DEBUG, INFO, WARN, ERROR, FATAL і UNKNOWN - і вирішує, що з ними робити: вивести їх, зберегти у файл, відправити через мережу і т.д.

## Див. також
Для поглиблення в тему вбудованого модуля логування Ruby, ознайомтеся з офіційною документацією:

Якщо ви зацікавлені у більш розширеному логуванні або хочете дослідити сторонні геми:
- [Lograge](https://github.com/roidrage/lograge)

Для загальних практик та філософії логування (не специфічних для Ruby), ці статті є вічнозеленими читаннями:
- [Книга про надійність сайтів від Google - Розділ 16: Обробка перевантажень](https://sre.google/sre-book/handling-overload/#log-messages)
- [12-факторний додаток - Логи](https://12factor.net/logs)
