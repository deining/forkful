---
date: 2024-01-26 01:09:44.024048-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0432\u0438 \u0445\u043E\u0447\
  \u0435\u0442\u0435 \u0437\u043C\u0443\u0441\u0438\u0442\u0438 \u0441\u0432\u0456\
  \u0442\u043B\u043E\u0434\u0456\u043E\u0434 \u043C\u0438\u0433\u0442\u0456\u0442\u0438\
  . \u0411\u0435\u0437 \u0444\u0443\u043D\u043A\u0446\u0456\u0439 \u0432\u0430\u0448\
  \ `loop` \u0454 \u043D\u0435\u043F\u0440\u0438\u0431\u0440\u0430\u043D\u0438\u043C\
  \ \u0431\u0435\u0437\u043B\u0430\u0434\u043E\u043C. \u0417 \u0444\u0443\u043D\u043A\
  \u0446\u0456\u044F\u043C\u0438 \u0432\u0441\u0435 \u0430\u043A\u0443\u0440\u0430\
  \u0442\u043D\u043E. \u041E\u0441\u044C \u044F\u043A."
lastmod: '2024-03-13T22:44:49.727396-06:00'
model: gpt-4-1106-preview
summary: "\u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0432\u0438 \u0445\u043E\
  \u0447\u0435\u0442\u0435 \u0437\u043C\u0443\u0441\u0438\u0442\u0438 \u0441\u0432\
  \u0456\u0442\u043B\u043E\u0434\u0456\u043E\u0434 \u043C\u0438\u0433\u0442\u0456\u0442\
  \u0438."
title: "\u041E\u0440\u0433\u0430\u043D\u0456\u0437\u0430\u0446\u0456\u044F \u043A\u043E\
  \u0434\u0443 \u0432 \u0444\u0443\u043D\u043A\u0446\u0456\u0457"
weight: 18
---

## Як це зробити:
Уявіть, що ви хочете змусити світлодіод мигтіти. Без функцій ваш `loop` є неприбраним безладом. З функціями все акуратно. Ось як:

```Arduino
const int LED_PIN = 13;

void setup() {
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  blinkLED(500); // Миготіння світлодіода кожні 500 мс
}

// Функція для миготіння світлодіода
void blinkLED(int delayTime) {
  digitalWrite(LED_PIN, HIGH);
  delay(delayTime);
  digitalWrite(LED_PIN, LOW);
  delay(delayTime);
}
```

Приклад результата: Ваш світлодіод весело миготить, і мета коду зрозуміла з першого погляду.

## Поглиблений Дайджест
До функцій програмування було схоже на лінійну дорожню подорож; ви бачили кожен вибоїну зі старту до фінішу. Після функцій це більше схоже на переліт літаком - ви переходите до важливих частин. Історично, підпрограми (ранні функції) були революцією у програмуванні, дозволяючи кодерам уникати повторення себе – це принцип DRY, Don't Repeat Yourself (Не повторюйте себе). Альтернативи функціям можуть включати макроси або використання класів для об'єктно-орієнтованого програмування (OOP). Детальніше? Коли ви визначаєте функцію, ви даєте компілятору креслення для виконання завдання. З Arduino, ви часто визначаєте void функції, які діють як прості команди для мікроконтролера, але функції також можуть повертати значення, що робить їх більш універсальними.

## Дивіться також
Щоб дізнатися більше про функції, перегляньте наступне:

- Офіційна довідка функцій Arduino: https://www.arduino.cc/reference/en/language/functions/
- Дізнатися більше про принцип DRY: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
- Освіжіть в історії підпрограм: https://en.wikipedia.org/wiki/Subroutine
