---
date: 2024-01-26 03:43:06.164287-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0412 Arduino \u0432\u0438 \u043C\u043E\u0436\u0435\u0442\u0435 \u043E\u043A\u0440\
  \u0443\u0433\u043B\u044F\u0442\u0438 \u0447\u0438\u0441\u043B\u0430, \u0432\u0438\
  \u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u044E\u0447\u0438 \u0432\u0431\
  \u0443\u0434\u043E\u0432\u0430\u043D\u0456 \u0444\u0443\u043D\u043A\u0446\u0456\u0457\
  . \u041A\u043B\u044E\u0447\u043E\u0432\u0456 \u0454 `round`, `ceil` \u0456 `floor`.\
  \ \u041E\u0441\u044C \u043A\u043E\u0440\u043E\u0442\u043A\u0430 \u0434\u0435\u043C\
  \u043E\u043D\u0441\u0442\u0440\u0430\u0446\u0456\u044F."
lastmod: '2024-03-13T22:44:49.711345-06:00'
model: gpt-4-0125-preview
summary: "\u0412 Arduino \u0432\u0438 \u043C\u043E\u0436\u0435\u0442\u0435 \u043E\u043A\
  \u0440\u0443\u0433\u043B\u044F\u0442\u0438 \u0447\u0438\u0441\u043B\u0430, \u0432\
  \u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u044E\u0447\u0438 \u0432\
  \u0431\u0443\u0434\u043E\u0432\u0430\u043D\u0456 \u0444\u0443\u043D\u043A\u0446\u0456\
  \u0457."
title: "\u041E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u043D\u044F \u0447\u0438\u0441\
  \u0435\u043B"
weight: 13
---

## Як це зробити:
В Arduino ви можете округляти числа, використовуючи вбудовані функції. Ключові є `round`, `ceil` і `floor`. Ось коротка демонстрація:

```arduino
void setup() {
  Serial.begin(9600);
  
  float myNumber = 123.4567;

  // Округлення до найближчого цілого числа
  Serial.println(round(myNumber)); // Виводить: 123

  // Завжди округляє вгору
  Serial.println(ceil(myNumber));  // Виводить: 124

  // Завжди округляє вниз
  Serial.println(floor(myNumber)); // Виводить: 123
}

void loop() {
  // Немає чого циклічно обробляти.
}
```

## Поглиблене Вивчення:
Алгоритми округлення мають довгу історію; вони існували задовго до цифрових комп'ютерів. В аналоговому обчисленні округлення було фізичним процесом. В цифровому обчисленні це математичний процес.

Округлення потрібне, коли ми конвертуємо з типу з більшою точністю (наприклад, `float` або `double`) у тип з меншою точністю (наприклад, `int`). Але спосіб округлення може варіюватися:

1. `round()`: Стандартне округлення. Якщо дробова частина 0.5 або вище, округляється вгору; інакше вниз.
2. `ceil()`: Скорочення від "стеля", завжди округляє вгору до найближчого цілого числа, навіть якщо воно ближче до нижнього числа.
3. `floor()`: Протилежність стелі; завжди округляє вниз.

Вибір між цими функціями залежить від того, для чого потрібне округлене значення. Міряння можуть потребувати стандартного округлення, гроші часто використовують `floor`, тоді як системи інвентаризації можуть використовувати `ceil`, щоб все було враховано.

Реалізація цих функцій в Arduino є простою; вони не обробляють додаткові випадки, наприклад, округлення до конкретних десяткових місць. Для цього потрібна власна функція або глибше математичне розуміння – подумайте про множення для зсуву десяткового розряду, округлення, а потім повернення через ділення.

Помилки округлення можуть накопичуватися, значно впливаючи на тривалі обчислення або ітераційні процеси. Програмістам потрібно бути обережними при виконанні численних операцій з округленими значеннями.

## Дивіться також:
2. Поглиблений погляд на підводні камені та стратегії округлення: [Floating Point Guide](https://floating-point-gui.de/)
3. Для перегляду розширених технік, включаючи власні функції округлення та обробку помилок округлення, ви можете переглянути академічні ресурси або детальні програмні керівництва.
