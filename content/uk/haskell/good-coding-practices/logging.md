---
date: 2024-01-26 01:07:52.444523-07:00
description: "\u042F\u043A \u0446\u0435 \u0440\u043E\u0431\u0438\u0442\u0438: \u0412\
  \ Haskell \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0436\
  \u043B\u0438\u0432\u0435 \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\
  \u043E\u044E \u0431\u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A, \u0442\u0430\
  \u043A\u0438\u0445 \u044F\u043A `monad-logger` \u0430\u0431\u043E `hslogger`. \u041E\
  \u0441\u044C \u0448\u0432\u0438\u0434\u043A\u0438\u0439 \u043F\u0440\u0438\u043A\
  \u043B\u0430\u0434 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\
  \u044F `monad-logger`."
lastmod: '2024-03-13T22:44:49.370740-06:00'
model: gpt-4-1106-preview
summary: "\u0412 Haskell \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F \u043C\
  \u043E\u0436\u043B\u0438\u0432\u0435 \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\
  \u043E\u0433\u043E\u044E \u0431\u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A\
  , \u0442\u0430\u043A\u0438\u0445 \u044F\u043A `monad-logger` \u0430\u0431\u043E\
  \ `hslogger`."
title: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F"
weight: 17
---

## Як це робити:
В Haskell логування можливе за допомогою бібліотек, таких як `monad-logger` або `hslogger`. Ось швидкий приклад використання `monad-logger`:

```Haskell
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad.Logger
import Control.Monad.IO.Class (liftIO)

logExample :: LoggingT IO ()
logExample = do
    logInfoN "Запускаємо аплікацію..."
    liftIO $ putStrLn "Виконуємо критично важливу роботу..."
    logErrorN "Ой! Виникла якась проблема."

main :: IO ()
main = runStdoutLoggingT logExample

{- Приклад виводу
[Info] Запускаємо аплікацію...
Виконуємо критично важливу роботу...
[Error] Ой! Виникла якась проблема.
-}
```

Цей простий приклад демонструє, як ви можете розміщувати декларації логування в вашому коді, щоб отримати уявлення про те, що відбувається під час роботи програми. `logInfoN` і `logErrorN` використовуються для логування інформаційних та повідомлень про помилки відповідно.

## Поглиблюємо:
Логування пройшло довгий шлях від простих операторів друку до складних логувальних фреймворків. Історично, логи були просто текстовими виводами на консоль або у файл, а тепер вони включають структуровані дані, які можуть бути розібрані та проаналізовані різними інструментами.

В Haskell логування може виконуватися у чистому функціональному стилі, що включає явну передачу дій логування, або використання монадичних контекстів для нечистот, де логери неявно проходять через обчислення.

Бібліотека `hslogger`, наприклад, є більш традиційною та змінною порівняно з `monad-logger`. `monad-logger` пропонує інтеграцію з монадичним стеком та забезпечує більше гнучкості в плані форматування виводу та контролю. Обидві бібліотеки дозволяють вам встановлювати рівні журналювання, які допомагають фільтрувати повідомлення журналу залежно від їх важливості. Рівні журналювання включають debug, info, notice, warning, error, critical, alert і emergency.

Підхід Haskell до логування часто відповідає його акценту на типовій безпеці та чистоті. Логи можуть оброблятися таким чином, що навіть якщо логування зазнає невдачі, воно не спричинить збою основного додатка завдяки потужним можливостям обробки помилок в Haskell.

## Дивіться також:
- [Документація `monad-logger` на Hackage](https://hackage.haskell.org/package/monad-logger)
- [Пакет `hslogger` на Hackage](https://hackage.haskell.org/package/hslogger)
- [Real World Haskell, Глава 19, про Обробку Помилок](http://book.realworldhaskell.org/read/error-handling.html)
- [Фасад Логування для Haskell (log-base)](https://hackage.haskell.org/package/log-base)
