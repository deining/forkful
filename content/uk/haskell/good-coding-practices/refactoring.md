---
date: 2024-01-26 01:38:37.494778-07:00
description: "\u042F\u043A: \u041F\u0440\u0438\u043F\u0443\u0441\u0442\u0438\u043C\
  \u043E, \u0443 \u0432\u0430\u0441 \u0454 \u0447\u0430\u0441\u0442\u0438\u043D\u0430\
  \ \u043A\u043E\u0434\u0443 \u043D\u0430 Haskell, \u044F\u043A\u0430 \u043F\u043E\
  \u0432\u0442\u043E\u0440\u044E\u0454\u0442\u044C\u0441\u044F \u0447\u0430\u0441\u0442\
  \u0456\u0448\u0435, \u043D\u0456\u0436 \u0432\u0430\u0448\u0430 \u0443\u043B\u044E\
  \u0431\u043B\u0435\u043D\u0430 \u043F\u0456\u0441\u043D\u044F. \u041E\u0441\u044C\
  \ \u0448\u0432\u0438\u0434\u043A\u0438\u0439 \u043F\u043E\u0433\u043B\u044F\u0434\
  \ \u043D\u0430 \u0442\u0435, \u044F\u043A \u0432\u0438 \u043C\u043E\u0433\u043B\u0438\
  \ \u0431 \u0440\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u0442\u0438 \u0446\
  \u0435\u2026"
lastmod: '2024-03-13T22:44:49.374187-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u0440\u0438\u043F\u0443\u0441\u0442\u0438\u043C\u043E, \u0443 \u0432\
  \u0430\u0441 \u0454 \u0447\u0430\u0441\u0442\u0438\u043D\u0430 \u043A\u043E\u0434\
  \u0443 \u043D\u0430 Haskell, \u044F\u043A\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\
  \u044E\u0454\u0442\u044C\u0441\u044F \u0447\u0430\u0441\u0442\u0456\u0448\u0435\
  , \u043D\u0456\u0436 \u0432\u0430\u0448\u0430 \u0443\u043B\u044E\u0431\u043B\u0435\
  \u043D\u0430 \u043F\u0456\u0441\u043D\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Як:
Припустимо, у вас є частина коду на Haskell, яка повторюється частіше, ніж ваша улюблена пісня. Ось швидкий погляд на те, як ви могли б рефакторити це за допомогою функцій.

До рефакторингу:

```haskell
printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  putStrLn $ "Замовник: " ++ customer
  putStrLn $ "Всього: " ++ show total
  putStrLn $ "Предмет: " ++ item
```

Після невеликого рефакторингу:

```haskell
printDetail :: String -> String -> IO ()
printDetail label value = putStrLn $ label ++ ": " ++ value

printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  printDetail "Замовник" customer
  printDetail "Всього" (show total)
  printDetail "Предмет" item

-- Приклад виводу:
-- Замовник: Аліса
-- Всього: $42.00
-- Предмет: Путівник з програмування на Haskell
```

Як ви можете бачити, екстрагуючи спільний шаблон в окрему функцію `printDetail`, ми уникаємо повторення і робимо `printInvoice` чіткішим і легшим для управління.

## Поглиблене занурення
Коли Haskell з'явився наприкінці 80-х, було зрозуміло, що функціональний парадигм може принести свіжий подих у практики кодування. Швидко промотуючи вперед, рефакторинг на Haskell є особливо елегантним завдяки функціям, що є громадянами першого класу, та його сильній статичній системі типів. Ви рефакторите, не побоюючись, що зламаєте свій додаток, оскільки компілятор стоїть на вашому боці.

Альтернативи ручному рефакторингу можуть включати використання автоматизованих інструментів, хоча функціональна природа та типова безпека Haskell іноді можуть робити це менш поширеним в порівнянні з іншими мовами. З точки зору впровадження, важливо використовувати можливості Haskell, такі як функції вищого порядку, чистота та незмінність, для спрощення рефакторингу.

Рефакторинги на кшталт "Витягнути Функцію", щойно продемонстрованого, є поширеними, але ви також можете виконувати "Інлайн Функцію", "Перейменувати Змінну" та "Змінити Сигнатуру Функції" з упевненістю, завдяки системі типів. Могутня типова інференція Haskell іноді може виявити помилки, які змогли б проскочити в інших мовах.

## Дивіться також
Для поглибленого занурення в рефакторинг на Haskell загляньте до книги "Рефакторинг: Покращення дизайну існуючого коду" Мартіна Фаулера, де концепції універсально застосовні. Перевірте інструмент hlint для автоматизованих підказок щодо покращення вашого коду на Haskell. Також завітайте на вікі Haskell (https://wiki.haskell.org/Refactoring) за інсайтами спільноти та подальшим читанням.
