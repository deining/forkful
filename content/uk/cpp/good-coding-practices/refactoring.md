---
date: 2024-01-26 01:18:36.388255-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0443 \u0432\u0430\u0441 \u0454\
  \ \u0444\u0443\u043D\u043A\u0446\u0456\u044F, \u044F\u043A\u0430 \u0440\u043E\u0431\
  \u0438\u0442\u044C \u0442\u0440\u043E\u0445\u0438 \u0437\u0430\u0431\u0430\u0433\
  \u0430\u0442\u043E, \u044F\u043A \u043E\u0442 \u0446\u0435\u0439 \u0441\u043A\u043B\
  \u0430\u0434\u043D\u0438\u0439 \u043C\u0435\u0442\u043E\u0434, \u0449\u043E \u0456\
  \u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u0443\u0454 \u043E\u0431'\u0454\
  \u043A\u0442, \u0430 \u0442\u0430\u043A\u043E\u0436 \u0432\u0438\u043A\u043E\u043D\
  \u0443\u0454 \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F."
lastmod: '2024-03-13T22:44:49.859380-06:00'
model: gpt-4-0125-preview
summary: "\u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0443 \u0432\u0430\u0441\
  \ \u0454 \u0444\u0443\u043D\u043A\u0446\u0456\u044F, \u044F\u043A\u0430 \u0440\u043E\
  \u0431\u0438\u0442\u044C \u0442\u0440\u043E\u0445\u0438 \u0437\u0430\u0431\u0430\
  \u0433\u0430\u0442\u043E, \u044F\u043A \u043E\u0442 \u0446\u0435\u0439 \u0441\u043A\
  \u043B\u0430\u0434\u043D\u0438\u0439 \u043C\u0435\u0442\u043E\u0434, \u0449\u043E\
  \ \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u0443\u0454 \u043E\u0431\
  '\u0454\u043A\u0442, \u0430 \u0442\u0430\u043A\u043E\u0436 \u0432\u0438\u043A\u043E\
  \u043D\u0443\u0454 \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Як це зробити:
Уявіть, що у вас є функція, яка робить трохи забагато, як от цей складний метод, що ініціалізує об'єкт, а також виконує логування:

```C++
#include <iostream>

class Widget {
public:
    void init(bool verbose) {
        // Логіка ініціалізації
        // ...

        // Детальне логування
        if (verbose) {
            std::cout << "Віджет ініціалізовано!" << std::endl;
        }
    }
};

// Використання:
Widget w;
w.init(true);
```

Вивід:
```
Віджет ініціалізовано!
```

Рефакторинг цього до чистіших, більш фокусованих методів може виглядати так:

```C++
#include <iostream>

class Widget {
public:
    void init() {
        // Тільки логіка ініціалізації
        // ...
    }

    void logInitialization() const {
        std::cout << "Віджет ініціалізовано!" << std::endl;
    }
};

// Використання:
Widget w;
w.init();
w.logInitialization();
```

Ця зміна не змінила те, що робить програма, але зробила клас `Widget` більш модульним і його використання більш зрозумілим.

## Поглиблений огляд
Концепція рефакторингу, як ми її знаємо сьогодні, має свої корені у спільнотах програмування на Smalltalk 1980-х років і була сильно популяризована книгою Мартіна Фаулера "Refactoring: Improving the Design of Existing Code" 1999 року. Сьогодні, рефакторинг є основною частиною сучасної розробки програмного забезпечення, інтегрованою в різні методології розробки, такі як Agile та TDD (розробка через тестування).

Коли ми говоримо про альтернативи рефакторингу, ми заходимо в область переписування або перепроектування. Рефакторинг є стратегічним та інкрементним, тоді як переписування може відмовитися від існуючого коду на користь нового рішення. Перепроектування, в свою чергу, може включати значні зміни, включаючи зміну функціональності, що є неціллю для чистого рефакторингу.

Деталі імплементації рефакторингу можуть бути досить детальними. Існує багато "поганих запахів" коду, які можуть спонукати до рефакторингу, такі як довгі методи, великі класи, або дубльований код. Існують автоматизовані інструменти, які можуть допомогти в рефакторингу, такі як "Clang-Tidy" для C++, які можуть виявляти проблеми та навіть застосувати деякі виправлення.

Більше того, для рефакторингу потрібен міцний набір тестів, щоб переконатися, що функціональність залишається незмінною. Без тестів ви по суті літаете всліпу та ризикуєте регресією.

## Див. також
Для глибшого розуміння рефакторингу та для більшої кількості прикладів, ви можете ознайомитися з:

- Класичним текстом Мартіна Фаулера "Refactoring: Improving the Design of Existing Code" для основних ідей та стратегій.
- Документацією `Clang-Tidy` за адресою https://clang.llvm.org/extra/clang-tidy/ для автоматизованої підтримки рефакторингу в C++.
- "Working Effectively with Legacy Code" Майкла Фезерса, який надає техніки безпечного рефакторингу в контексті неідеальних існуючих кодових баз.
