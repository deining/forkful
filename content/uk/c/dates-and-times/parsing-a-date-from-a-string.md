---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:05:46.300822-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : C \u043D\u0435 \u043D\u0430\u0434\u0430\u0454 \u0432\u0431\u0443\u0434\u043E\u0432\
  \u0430\u043D\u043E\u0433\u043E \u0441\u043F\u043E\u0441\u043E\u0431\u0443 \u0431\
  \u0435\u0437\u043F\u043E\u0441\u0435\u0440\u0435\u0434\u043D\u044C\u043E \u0430\u043D\
  \u0430\u043B\u0456\u0437\u0443\u0432\u0430\u0442\u0438 \u0434\u0430\u0442\u0438\
  \ \u0437 \u0440\u044F\u0434\u043A\u0456\u0432, \u0442\u043E\u043C\u0443 \u043C\u0438\
  \ \u0447\u0430\u0441\u0442\u043E \u0437\u0432\u0435\u0440\u0442\u0430\u0454\u043C\
  \u043E\u0441\u044C \u0434\u043E \u0444\u0443\u043D\u043A\u0446\u0456\u0457 `strptime`,\
  \ \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0457 \u0443\u2026"
lastmod: '2024-03-13T22:44:50.163834-06:00'
model: gpt-4-0125-preview
summary: "C \u043D\u0435 \u043D\u0430\u0434\u0430\u0454 \u0432\u0431\u0443\u0434\u043E\
  \u0432\u0430\u043D\u043E\u0433\u043E \u0441\u043F\u043E\u0441\u043E\u0431\u0443\
  \ \u0431\u0435\u0437\u043F\u043E\u0441\u0435\u0440\u0435\u0434\u043D\u044C\u043E\
  \ \u0430\u043D\u0430\u043B\u0456\u0437\u0443\u0432\u0430\u0442\u0438 \u0434\u0430\
  \u0442\u0438 \u0437 \u0440\u044F\u0434\u043A\u0456\u0432, \u0442\u043E\u043C\u0443\
  \ \u043C\u0438 \u0447\u0430\u0441\u0442\u043E \u0437\u0432\u0435\u0440\u0442\u0430\
  \u0454\u043C\u043E\u0441\u044C \u0434\u043E \u0444\u0443\u043D\u043A\u0446\u0456\
  \u0457 `strptime`, \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0457 \u0443\
  \ \u0431\u0456\u0431\u043B\u0456\u043E\u0442\u0435\u0446\u0456 `<time.h>` \u0434\
  \u043B\u044F \u0441\u0438\u0441\u0442\u0435\u043C POSIX."
title: "\u0420\u043E\u0437\u0431\u0456\u0440 \u0434\u0430\u0442\u0438 \u0437 \u0440\
  \u044F\u0434\u043A\u0430"
weight: 30
---

## Як це зробити:
C не надає вбудованого способу безпосередньо аналізувати дати з рядків, тому ми часто звертаємось до функції `strptime`, доступної у бібліотеці `<time.h>` для систем POSIX. Ця функція дозволяє нам вказати очікуваний формат вхідного рядка та аналізувати його у `struct tm`, яка представляє календарну дату та час, розділені на компоненти.

Ось простий приклад використання `strptime` для розбору дати з рядка:

```c
#include <time.h>
#include <stdio.h>

int main() {
    const char *dateStr = "2023-04-01";
    struct tm tm;
    char buf[255];

    // Розбір рядка дати у struct tm
    if (strptime(dateStr, "%Y-%m-%d", &tm) == NULL) {
        printf("Не вдалося розібрати дату.\n");
    } else {
        // Використання strftime для виведення дати у читабельному форматі
        strftime(buf, sizeof(buf), "%A, %B %d, %Y", &tm);
        printf("Розібрана дата: %s\n", buf);
    }

    return 0;
}
```

Приклад виводу для цієї програми:

```
Розібрана дата: субота, квітень 01, 2023
```

Важливо обробляти потенційні помилки, такі як невдале співставлення шаблону `strptime` або зіткнення з неочікуваним вводом.

## Поглиблений аналіз
Функція `strptime`, хоча й потужна, не є частиною стандартної бібліотеки С та зазвичай знаходиться в системах, сумісних з POSIX, таких як Linux та UNIX. Це обмеження означає, що програми, які покладаються на `strptime` для аналізу дат з рядків, можуть не бути портативними до не-POSIX систем, таких як Windows, без додаткових шарів сумісності або бібліотек.

Історично, робота з датами та часом у C вимагала багато ручної маніпуляції та обережності, особливо враховуючи різні локалі та часові зони. Сучасні альтернативи і розширення до C, такі як бібліотека `<chrono>` для C++ та сторонні бібліотеки, наприклад, бібліотека дат Howard Hinnant для C++, пропонують більш міцні рішення для маніпуляції з датою та часом, включаючи аналіз. Ці бібліотеки зазвичай надають кращу підтримку широкого спектру форматів дат, часових зон і механізмів обробки помилок, роблячи їх переважними для нових проектів, які вимагають обширних можливостей маніпуляції з датою та часом.

Проте, розуміння способу розбору дат з рядків у C може бути корисним, особливо при роботі над або обслуговуванні проектів, які мають бути сумісними з системами, де ці сучасні інструменти недоступні, або при роботі у рамках строгих умов програмування на мові С.
