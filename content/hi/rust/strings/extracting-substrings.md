---
date: 2024-01-20 17:47:28.849441-07:00
description: "How to: (\u0915\u0948\u0938\u0947 \u0915\u0930\u0947\u0902:) \u0927\u094D\
  \u092F\u093E\u0928 \u0926\u0947\u0902 \u0915\u093F Rust \u0938\u094D\u091F\u094D\
  \u0930\u093F\u0902\u0917\u094D\u0938 UTF-8 encoded \u0939\u094B\u0924\u0940 \u0939\
  \u0948\u0902, \u0907\u0938\u0932\u093F\u090F \u0907\u0902\u0921\u0947\u0915\u094D\
  \u0938 \u092C\u093E\u0907\u091F\u094D\u0938 \u0915\u0947 \u0906\u0927\u093E\u0930\
  \ \u092A\u0930 \u0939\u094B\u0924\u0947 \u0939\u0948\u0902, \u0928 \u0915\u093F\
  \ \u091A\u0930\u093F\u0924\u094D\u0930\u094B\u0902 \u0915\u0947\u0964."
lastmod: '2024-04-05T21:53:53.946155-06:00'
model: gpt-4-1106-preview
summary: "(\u0915\u0948\u0938\u0947 \u0915\u0930\u0947\u0902:) \u0927\u094D\u092F\u093E\
  \u0928 \u0926\u0947\u0902 \u0915\u093F Rust \u0938\u094D\u091F\u094D\u0930\u093F\
  \u0902\u0917\u094D\u0938 UTF-8 encoded \u0939\u094B\u0924\u0940 \u0939\u0948\u0902\
  , \u0907\u0938\u0932\u093F\u090F \u0907\u0902\u0921\u0947\u0915\u094D\u0938 \u092C\
  \u093E\u0907\u091F\u094D\u0938 \u0915\u0947 \u0906\u0927\u093E\u0930 \u092A\u0930\
  \ \u0939\u094B\u0924\u0947 \u0939\u0948\u0902, \u0928 \u0915\u093F \u091A\u0930\u093F\
  \u0924\u094D\u0930\u094B\u0902 \u0915\u0947\u0964."
title: "\u0938\u092C\u0938\u094D\u091F\u094D\u0930\u093F\u0902\u0917\u094D\u0938 \u0928\
  \u093F\u0915\u093E\u0932\u0928\u093E"
weight: 6
---

## How to: (कैसे करें:)
```Rust
fn main() {
    let my_string = "नमस्ते, Rust दुनिया!";
    let start = 9; // शुरुआत का इंडेक्स
    let end = 13; // अंत का इंडेक्स
    let substring = &my_string[start..end];
    
    println!("Extracted substring: {}", substring);
}

// सैंपल आउटपुट:
// Extracted substring: Rust
```

ध्यान दें कि Rust स्ट्रिंग्स UTF-8 encoded होती हैं, इसलिए इंडेक्स बाइट्स के आधार पर होते हैं, न कि चरित्रों के।

## Deep Dive (गहराई में जानकारी):
Rust में substring निकालने का तरीका स्मृति सुरक्षा और दक्षता पर केंद्रित है। पुरानी प्रोग्रामिंग भाषाओं में, जैसे C/C++, सबस्ट्रिंग्स हैंडल करना स्मृति सुरक्षा के दृष्टिकोण से जोखिम भरा था क्योंकि यह रन टाइम त्रुटियों का कारण बन सकता था। Rust में, स्लाइसिंग सिंटैक्स आपको सटीक बाइट इंडेक्स द्वारा स्मृति स्थान का सबसेट लेने की अनुमति देता है, जो कंपाइलर द्वारा चेक की जाती हैं। 

अल्टरनेटिव के रूप में, आप `str` मेथड `get()` या `chars().nth()` का उपयोग कर सकते हैं, जो सुरक्षित है क्योंकि ये आपको `Option` टाइप लौटाते हैं, जिसका `None` वैल्यू का मतलब है कि रिक्वेस्टेड सबस्ट्रिंग मान्य नहीं है। हालांकि, यह ज्यादा सुस्त हो सकता है क्योंकि प्रत्येक चरित्र के लिए चेक किया जाता है। 

स्लाइसिंग का उपयोग करना तेज़ होता है लेकिन बाइट बाउंडरी एरर (byte boundary error) उ‍त्पन्न हो सकते हैं यदि आप मल्टीबाइट चरित्र को गलत तरीके से काटते हैं, इसलिए सावधानी बरतें।

## See Also (और देखें):
- Rust डाक्यूमेंटेशन में बाइटस्ट्रिंग्स पर और पढ़ें [Rust Book - Byte Strings](https://doc.rust-lang.org/book/ch08-02-strings.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my).
- स्ट्रिंग स्लाइसिंग के अधिक उदाहरणों के लिए [Rust by Example](https://doc.rust-lang.org/rust-by-example/std/str.html) देखें।
- अधिक जटिल टेक्स्ट मेनिपुलेशन ऑपरेशंस के लिए `regex` क्रेट का इस्तेमाल कैसे करें यह सीखें [Rust Regex Crate](https://docs.rs/regex/1.3.9/regex/).
