---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:13:29.576559-07:00
description: "\u0915\u0948\u0938\u0947: Rust \u092E\u0947\u0902, `std::collections`\
  \ \u092E\u0949\u0921\u094D\u092F\u0942\u0932 \u0938\u0947 `HashMap` \u092A\u094D\
  \u0930\u0915\u093E\u0930 \u0938\u0902\u092C\u0926\u094D\u0927 \u090F\u0930\u0947\
  \ \u0915\u0940 \u0915\u093E\u0930\u094D\u092F\u0915\u094D\u0937\u092E\u0924\u093E\
  \ \u092A\u094D\u0930\u0926\u093E\u0928 \u0915\u0930\u0924\u093E \u0939\u0948\u0964\
  \ \u092F\u0939\u093E\u0901 \u0906\u092A \u0909\u0928\u0915\u0947 \u0938\u093E\u0925\
  \ \u0915\u093E\u092E \u0915\u0948\u0938\u0947 \u0915\u0930 \u0938\u0915\u0924\u0947\
  \ \u0939\u0948\u0902."
lastmod: '2024-03-13T22:44:51.949282-06:00'
model: gpt-4-0125-preview
summary: "Rust \u092E\u0947\u0902, `std::collections` \u092E\u0949\u0921\u094D\u092F\
  \u0942\u0932 \u0938\u0947 `HashMap` \u092A\u094D\u0930\u0915\u093E\u0930 \u0938\u0902\
  \u092C\u0926\u094D\u0927 \u090F\u0930\u0947 \u0915\u0940 \u0915\u093E\u0930\u094D\
  \u092F\u0915\u094D\u0937\u092E\u0924\u093E \u092A\u094D\u0930\u0926\u093E\u0928\
  \ \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u092F\u0939\u093E\u0901 \u0906\u092A\
  \ \u0909\u0928\u0915\u0947 \u0938\u093E\u0925 \u0915\u093E\u092E \u0915\u0948\u0938\
  \u0947 \u0915\u0930 \u0938\u0915\u0924\u0947 \u0939\u0948\u0902."
title: "\u0938\u0939\u092F\u094B\u0917\u0940 \u0905\u0930\u0947\u091C\u093C \u0915\
  \u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u093E"
weight: 15
---

## कैसे:
Rust में, `std::collections` मॉड्यूल से `HashMap` प्रकार संबद्ध एरे की कार्यक्षमता प्रदान करता है। यहाँ आप उनके साथ काम कैसे कर सकते हैं:

```Rust
use std::collections::HashMap;

fn main() {
    // एक नया HashMap बनाना
    let mut scores = HashMap::new();

    // मूल्य डालना
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // मूल्यों का प्राप्त करना
    let team_name = String::from("Blue");
    if let Some(score) = scores.get(&team_name) {
        println!("Blue टीम के लिए स्कोर: {}", score); // परिणाम: Blue टीम के लिए स्कोर: 10
    }

    // एक मूल्य को अपडेट करना
    scores.entry(String::from("Blue")).and_modify(|e| *e += 5);

    // कुंजी-मूल्य जोड़ों पर इटरेट करना
    for (key, value) in &scores {
        println!("{}: {}", key, value); // परिणाम: Blue: 15, Yellow: 50
    }
}
```

## गहराई में जानकारी
Rust का `HashMap` कुंजियों को मूल्यों से जोड़ने के लिए एक हैशिंग फंक्शन का उपयोग करता है, जो तेज़ी से डेटा पुनः प्राप्ति को सक्षम बनाता है। हालाँकि, यह कार्यक्षमता एक लागत के साथ आती है: हैश मैप्स उनके तत्वों के क्रम को बरकरार नहीं रखते हैं। यह पायथन (`dict`) या रूबी जैसी अन्य संबद्ध एरे कार्यान्वयनों के विपरीत है, जो हाल के संस्करणों में एक विशेषता के रूप में सम्मिलन क्रम बनाए रखती हैं। ऐसे मामलों में जहाँ कुंजी-मूल्य जोड़ों का क्रम महत्वपूर्ण होता है, Rust डेवलपर्स `std::collections` मॉड्यूल से `BTreeMap` का उपयोग करने पर विचार कर सकते हैं, जो क्रम को बनाए रखता है लेकिन `HashMap` की तुलना में धीमे सम्मिलन और पुनः प्राप्ति प्रदान कर सकता है। अंततः, `HashMap` और `BTreeMap` के बीच चयन विशेष आवश्यकताओं पर निर्भर करता है जो क्रम और प्रदर्शन से संबंधित होती हैं।
